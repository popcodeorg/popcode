{
  "ast": null,
  "code": "'use strict';\n\nvar high = require('highlight.js/lib/highlight.js');\n\nvar fault = require('fault');\n/* The lowlight interface, which has to be compatible\n * with highlight.js, as this object is passed to\n * highlight.js syntaxes. */\n\n\nfunction High() {}\n\nHigh.prototype = high;\n/* Expose. */\n\nvar low = new High(); // Ha!\n\nmodule.exports = low;\nlow.highlight = highlight;\nlow.highlightAuto = autoHighlight;\nlow.registerLanguage = registerLanguage;\nlow.registerAlias = registerAlias;\nlow.getLanguage = getLanguage;\nvar inherit = high.inherit;\nvar own = {}.hasOwnProperty;\nvar concat = [].concat;\nvar defaultPrefix = 'hljs-';\nvar keyInsensitive = 'case_insensitive';\nvar keyCachedVariants = 'cached_variants';\nvar space = ' ';\nvar pipe = '|';\nvar T_ELEMENT = 'element';\nvar T_TEXT = 'text';\nvar T_SPAN = 'span';\n/* Maps of syntaxes. */\n\nvar languageNames = [];\nvar languages = {};\nvar aliases = {};\n/* Highlighting with language detection.  Accepts a string\n * with the code to highlight.  Returns an object with the\n * following properties:\n *\n * - language (detected language)\n * - relevance (int)\n * - value (a HAST tree with highlighting markup)\n * - secondBest (object with the same structure for\n *   second-best heuristically detected language, may\n *   be absent) */\n\nfunction autoHighlight(value, options) {\n  var settings = options || {};\n  var subset = settings.subset || languageNames;\n  var prefix = settings.prefix;\n  var length = subset.length;\n  var index = -1;\n  var result;\n  var secondBest;\n  var current;\n  var name;\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n\n  secondBest = normalize({});\n  result = normalize({});\n\n  while (++index < length) {\n    name = subset[index];\n\n    if (!getLanguage(name)) {\n      continue;\n    }\n\n    current = normalize(coreHighlight(name, value, false, prefix));\n    current.language = name;\n\n    if (current.relevance > secondBest.relevance) {\n      secondBest = current;\n    }\n\n    if (current.relevance > result.relevance) {\n      secondBest = result;\n      result = current;\n    }\n  }\n\n  if (secondBest.language) {\n    result.secondBest = secondBest;\n  }\n\n  return result;\n}\n/* Highlighting `value` in the language `language`. */\n\n\nfunction highlight(language, value, options) {\n  var settings = options || {};\n  var prefix = settings.prefix;\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n\n  return normalize(coreHighlight(language, value, true, prefix));\n}\n/* Register a language. */\n\n\nfunction registerLanguage(name, syntax) {\n  var lang = syntax(low);\n  languages[name] = lang;\n  languageNames.push(name);\n\n  if (lang.aliases) {\n    registerAlias(name, lang.aliases);\n  }\n}\n/* Register more aliases for an already registered language. */\n\n\nfunction registerAlias(name, alias) {\n  var map = name;\n  var key;\n  var list;\n  var length;\n  var index;\n\n  if (alias) {\n    map = {};\n    map[name] = alias;\n  }\n\n  for (key in map) {\n    list = map[key];\n    list = typeof list === 'string' ? [list] : list;\n    length = list.length;\n    index = -1;\n\n    while (++index < length) {\n      aliases[list[index]] = key;\n    }\n  }\n}\n/* Core highlighting function.  Accepts a language name, or\n * an alias, and a string with the code to highlight.\n * Returns an object with the following properties: */\n\n\nfunction coreHighlight(name, value, ignore, prefix, continuation) {\n  var continuations = {};\n  var stack = [];\n  var modeBuffer = '';\n  var relevance = 0;\n  var language;\n  var top;\n  var current;\n  var currentChildren;\n  var offset;\n  var count;\n  var match;\n  var children;\n\n  if (typeof name !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', name);\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n\n  language = getLanguage(name);\n  top = continuation || language;\n  children = [];\n  current = top;\n  currentChildren = children;\n\n  if (!language) {\n    throw fault('Unknown language: `%s` is not registered', name);\n  }\n\n  compileLanguage(language);\n\n  try {\n    top.terminators.lastIndex = 0;\n    offset = 0;\n    match = top.terminators.exec(value);\n\n    while (match) {\n      count = processLexeme(value.substring(offset, match.index), match[0]);\n      offset = match.index + count;\n      top.terminators.lastIndex = offset;\n      match = top.terminators.exec(value);\n    }\n\n    processLexeme(value.substr(offset));\n    current = top;\n\n    while (current.parent) {\n      if (current.className) {\n        pop();\n      }\n\n      current = current.parent;\n    }\n\n    return {\n      relevance: relevance,\n      value: currentChildren,\n      language: name,\n      top: top\n    };\n  } catch (error) {\n    /* istanbul ignore if - Catch-all  */\n    if (error.message.indexOf('Illegal') === -1) {\n      throw error;\n    }\n\n    return {\n      relevance: 0,\n      value: addText(value, [])\n    };\n  }\n  /* Process a lexeme.  Returns next position. */\n\n\n  function processLexeme(buffer, lexeme) {\n    var newMode;\n    var endMode;\n    var origin;\n    modeBuffer += buffer;\n\n    if (lexeme === undefined) {\n      addSiblings(processBuffer(), currentChildren);\n      return 0;\n    }\n\n    newMode = subMode(lexeme, top);\n\n    if (newMode) {\n      addSiblings(processBuffer(), currentChildren);\n      startNewMode(newMode, lexeme);\n      return newMode.returnBegin ? 0 : lexeme.length;\n    }\n\n    endMode = endOfMode(top, lexeme);\n\n    if (endMode) {\n      origin = top;\n\n      if (!(origin.returnEnd || origin.excludeEnd)) {\n        modeBuffer += lexeme;\n      }\n\n      addSiblings(processBuffer(), currentChildren);\n      /* Close open modes. */\n\n      do {\n        if (top.className) {\n          pop();\n        }\n\n        relevance += top.relevance;\n        top = top.parent;\n      } while (top !== endMode.parent);\n\n      if (origin.excludeEnd) {\n        addText(lexeme, currentChildren);\n      }\n\n      modeBuffer = '';\n\n      if (endMode.starts) {\n        startNewMode(endMode.starts, '');\n      }\n\n      return origin.returnEnd ? 0 : lexeme.length;\n    }\n\n    if (isIllegal(lexeme, top)) {\n      throw fault('Illegal lexeme \"%s\" for mode \"%s\"', lexeme, top.className || '<unnamed>');\n    }\n    /* Parser should not reach this point as all\n     * types of lexemes should be caught earlier,\n     * but if it does due to some bug make sure it\n     * advances at least one character forward to\n     * prevent infinite looping. */\n\n\n    modeBuffer += lexeme;\n    return lexeme.length ||\n    /* istanbul ignore next */\n    1;\n  }\n  /* Start a new mode with a `lexeme` to process. */\n\n\n  function startNewMode(mode, lexeme) {\n    var node;\n\n    if (mode.className) {\n      node = build(mode.className, []);\n    }\n\n    if (mode.returnBegin) {\n      modeBuffer = '';\n    } else if (mode.excludeBegin) {\n      addText(lexeme, currentChildren);\n      modeBuffer = '';\n    } else {\n      modeBuffer = lexeme;\n    }\n    /* Enter a new mode. */\n\n\n    if (node) {\n      currentChildren.push(node);\n      stack.push(currentChildren);\n      currentChildren = node.children;\n    }\n\n    top = Object.create(mode, {\n      parent: {\n        value: top\n      }\n    });\n  }\n  /* Process the buffer. */\n\n\n  function processBuffer() {\n    var result = top.subLanguage ? processSubLanguage() : processKeywords();\n    modeBuffer = '';\n    return result;\n  }\n  /* Process a sublanguage (returns a list of nodes). */\n\n\n  function processSubLanguage() {\n    var explicit = typeof top.subLanguage === 'string';\n    var subvalue;\n    /* istanbul ignore if - support non-loaded sublanguages */\n\n    if (explicit && !languages[top.subLanguage]) {\n      return addText(modeBuffer, []);\n    }\n\n    if (explicit) {\n      subvalue = coreHighlight(top.subLanguage, modeBuffer, true, prefix, continuations[top.subLanguage]);\n    } else {\n      subvalue = autoHighlight(modeBuffer, {\n        subset: top.subLanguage.length === 0 ? undefined : top.subLanguage,\n        prefix: prefix\n      });\n    }\n    /* Counting embedded language score towards the\n     * host language may be disabled with zeroing the\n     * containing mode relevance.  Usecase in point is\n     * Markdown that allows XML everywhere and makes\n     * every XML snippet to have a much larger Markdown\n     * score. */\n\n\n    if (top.relevance > 0) {\n      relevance += subvalue.relevance;\n    }\n\n    if (explicit) {\n      continuations[top.subLanguage] = subvalue.top;\n    }\n\n    return [build(subvalue.language, subvalue.value, true)];\n  }\n  /* Process keywords. Returns nodes. */\n\n\n  function processKeywords() {\n    var nodes = [];\n    var lastIndex;\n    var keyword;\n    var node;\n    var submatch;\n\n    if (!top.keywords) {\n      return addText(modeBuffer, nodes);\n    }\n\n    lastIndex = 0;\n    top.lexemesRe.lastIndex = 0;\n    keyword = top.lexemesRe.exec(modeBuffer);\n\n    while (keyword) {\n      addText(modeBuffer.substring(lastIndex, keyword.index), nodes);\n      submatch = keywordMatch(top, keyword);\n\n      if (submatch) {\n        relevance += submatch[1];\n        node = build(submatch[0], []);\n        nodes.push(node);\n        addText(keyword[0], node.children);\n      } else {\n        addText(keyword[0], nodes);\n      }\n\n      lastIndex = top.lexemesRe.lastIndex;\n      keyword = top.lexemesRe.exec(modeBuffer);\n    }\n\n    addText(modeBuffer.substr(lastIndex), nodes);\n    return nodes;\n  }\n  /* Add siblings. */\n\n\n  function addSiblings(siblings, nodes) {\n    var length = siblings.length;\n    var index = -1;\n    var sibling;\n\n    while (++index < length) {\n      sibling = siblings[index];\n\n      if (sibling.type === T_TEXT) {\n        addText(sibling.value, nodes);\n      } else {\n        nodes.push(sibling);\n      }\n    }\n  }\n  /* Add a text. */\n\n\n  function addText(value, nodes) {\n    var tail;\n\n    if (value) {\n      tail = nodes[nodes.length - 1];\n\n      if (tail && tail.type === T_TEXT) {\n        tail.value += value;\n      } else {\n        nodes.push(buildText(value));\n      }\n    }\n\n    return nodes;\n  }\n  /* Build a text. */\n\n\n  function buildText(value) {\n    return {\n      type: T_TEXT,\n      value: value\n    };\n  }\n  /* Build a span. */\n\n\n  function build(name, contents, noPrefix) {\n    return {\n      type: T_ELEMENT,\n      tagName: T_SPAN,\n      properties: {\n        className: [(noPrefix ? '' : prefix) + name]\n      },\n      children: contents\n    };\n  }\n  /* Check if the first word in `keywords` is a keyword. */\n\n\n  function keywordMatch(mode, keywords) {\n    var keyword = keywords[0];\n\n    if (language[keyInsensitive]) {\n      keyword = keyword.toLowerCase();\n    }\n\n    return own.call(mode.keywords, keyword) && mode.keywords[keyword];\n  }\n  /* Check if `lexeme` is illegal according to `mode`. */\n\n\n  function isIllegal(lexeme, mode) {\n    return !ignore && test(mode.illegalRe, lexeme);\n  }\n  /* Check if `lexeme` ends `mode`. */\n\n\n  function endOfMode(mode, lexeme) {\n    if (test(mode.endRe, lexeme)) {\n      while (mode.endsParent && mode.parent) {\n        mode = mode.parent;\n      }\n\n      return mode;\n    }\n\n    if (mode.endsWithParent) {\n      return endOfMode(mode.parent, lexeme);\n    }\n  }\n  /* Check a sub-mode. */\n\n\n  function subMode(lexeme, mode) {\n    var values = mode.contains;\n    var length = values.length;\n    var index = -1;\n\n    while (++index < length) {\n      if (test(values[index].beginRe, lexeme)) {\n        return values[index];\n      }\n    }\n  }\n  /* Exit the current context. */\n\n\n  function pop() {\n    /* istanbul ignore next - removed in hljs 9.3 */\n    currentChildren = stack.pop() || children;\n  }\n}\n\nfunction expandMode(mode) {\n  var length;\n  var index;\n  var variants;\n  var result;\n\n  if (mode.variants && !mode[keyCachedVariants]) {\n    variants = mode.variants;\n    length = variants.length;\n    index = -1;\n    result = [];\n\n    while (++index < length) {\n      result[index] = inherit(mode, {\n        variants: null\n      }, variants[index]);\n    }\n\n    mode[keyCachedVariants] = result;\n  }\n\n  return mode[keyCachedVariants] || (mode.endsWithParent ? [inherit(mode)] : [mode]);\n}\n/* Compile a language. */\n\n\nfunction compileLanguage(language) {\n  compileMode(language);\n  /* Compile a language mode, optionally with a parent. */\n\n  function compileMode(mode, parent) {\n    var compiledKeywords = {};\n    var terminators;\n\n    if (mode.compiled) {\n      return;\n    }\n\n    mode.compiled = true;\n    mode.keywords = mode.keywords || mode.beginKeywords;\n\n    if (mode.keywords) {\n      if (typeof mode.keywords === 'string') {\n        flatten('keyword', mode.keywords);\n      } else {\n        Object.keys(mode.keywords).forEach(function (className) {\n          flatten(className, mode.keywords[className]);\n        });\n      }\n\n      mode.keywords = compiledKeywords;\n    }\n\n    mode.lexemesRe = langRe(mode.lexemes || /\\w+/, true);\n\n    if (parent) {\n      if (mode.beginKeywords) {\n        mode.begin = '\\\\b(' + mode.beginKeywords.split(space).join(pipe) + ')\\\\b';\n      }\n\n      if (!mode.begin) {\n        mode.begin = /\\B|\\b/;\n      }\n\n      mode.beginRe = langRe(mode.begin);\n\n      if (!mode.end && !mode.endsWithParent) {\n        mode.end = /\\B|\\b/;\n      }\n\n      if (mode.end) {\n        mode.endRe = langRe(mode.end);\n      }\n\n      mode.terminatorEnd = source(mode.end) || '';\n\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        mode.terminatorEnd += (mode.end ? pipe : '') + parent.terminatorEnd;\n      }\n    }\n\n    if (mode.illegal) {\n      mode.illegalRe = langRe(mode.illegal);\n    }\n\n    if (mode.relevance === undefined) {\n      mode.relevance = 1;\n    }\n\n    if (!mode.contains) {\n      mode.contains = [];\n    }\n\n    mode.contains = concat.apply([], mode.contains.map(function (c) {\n      return expandMode(c === 'self' ? mode : c);\n    }));\n    mode.contains.forEach(function (c) {\n      compileMode(c, mode);\n    });\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent);\n    }\n\n    terminators = mode.contains.map(map).concat([mode.terminatorEnd, mode.illegal]).map(source).filter(Boolean);\n    mode.terminators = terminators.length === 0 ? {\n      exec: execNoop\n    } : langRe(terminators.join(pipe), true);\n\n    function map(c) {\n      return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin;\n    }\n    /* Flatten a classname. */\n\n\n    function flatten(className, value) {\n      var pairs;\n      var pair;\n      var index;\n      var length;\n\n      if (language[keyInsensitive]) {\n        value = value.toLowerCase();\n      }\n\n      pairs = value.split(space);\n      length = pairs.length;\n      index = -1;\n\n      while (++index < length) {\n        pair = pairs[index].split(pipe);\n        compiledKeywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];\n      }\n    }\n  }\n  /* Create a regex for `value`. */\n\n\n  function langRe(value, global) {\n    return new RegExp(source(value), 'm' + (language[keyInsensitive] ? 'i' : '') + (global ? 'g' : ''));\n  }\n  /* Get the source of an expression or string. */\n\n\n  function source(re) {\n    return re && re.source || re;\n  }\n}\n/* Normalize a syntax result. */\n\n\nfunction normalize(result) {\n  return {\n    relevance: result.relevance || 0,\n    language: result.language || null,\n    value: result.value || []\n  };\n}\n/* Check if `expression` matches `lexeme`. */\n\n\nfunction test(expression, lexeme) {\n  var match = expression && expression.exec(lexeme);\n  return match && match.index === 0;\n}\n/* No-op exec. */\n\n\nfunction execNoop() {\n  return null;\n}\n/* Get a language by `name`. */\n\n\nfunction getLanguage(name) {\n  name = name.toLowerCase();\n  return languages[name] || languages[aliases[name]];\n}",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/lowlight/lib/core.js"
    ],
    "names": [
      "high",
      "require",
      "fault",
      "High",
      "prototype",
      "low",
      "module",
      "exports",
      "highlight",
      "highlightAuto",
      "autoHighlight",
      "registerLanguage",
      "registerAlias",
      "getLanguage",
      "inherit",
      "own",
      "hasOwnProperty",
      "concat",
      "defaultPrefix",
      "keyInsensitive",
      "keyCachedVariants",
      "space",
      "pipe",
      "T_ELEMENT",
      "T_TEXT",
      "T_SPAN",
      "languageNames",
      "languages",
      "aliases",
      "value",
      "options",
      "settings",
      "subset",
      "prefix",
      "length",
      "index",
      "result",
      "secondBest",
      "current",
      "name",
      "undefined",
      "normalize",
      "coreHighlight",
      "language",
      "relevance",
      "syntax",
      "lang",
      "push",
      "alias",
      "map",
      "key",
      "list",
      "ignore",
      "continuation",
      "continuations",
      "stack",
      "modeBuffer",
      "top",
      "currentChildren",
      "offset",
      "count",
      "match",
      "children",
      "compileLanguage",
      "terminators",
      "lastIndex",
      "exec",
      "processLexeme",
      "substring",
      "substr",
      "parent",
      "className",
      "pop",
      "error",
      "message",
      "indexOf",
      "addText",
      "buffer",
      "lexeme",
      "newMode",
      "endMode",
      "origin",
      "addSiblings",
      "processBuffer",
      "subMode",
      "startNewMode",
      "returnBegin",
      "endOfMode",
      "returnEnd",
      "excludeEnd",
      "starts",
      "isIllegal",
      "mode",
      "node",
      "build",
      "excludeBegin",
      "Object",
      "create",
      "subLanguage",
      "processSubLanguage",
      "processKeywords",
      "explicit",
      "subvalue",
      "nodes",
      "keyword",
      "submatch",
      "keywords",
      "lexemesRe",
      "keywordMatch",
      "siblings",
      "sibling",
      "type",
      "tail",
      "buildText",
      "contents",
      "noPrefix",
      "tagName",
      "properties",
      "toLowerCase",
      "call",
      "test",
      "illegalRe",
      "endRe",
      "endsParent",
      "endsWithParent",
      "values",
      "contains",
      "beginRe",
      "expandMode",
      "variants",
      "compileMode",
      "compiledKeywords",
      "compiled",
      "beginKeywords",
      "flatten",
      "keys",
      "forEach",
      "langRe",
      "lexemes",
      "begin",
      "split",
      "join",
      "end",
      "terminatorEnd",
      "source",
      "illegal",
      "apply",
      "c",
      "filter",
      "Boolean",
      "execNoop",
      "pairs",
      "pair",
      "Number",
      "global",
      "RegExp",
      "re",
      "expression"
    ],
    "mappings": "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",
    "sourcesContent": [
      "'use strict'\n\nvar high = require('highlight.js/lib/highlight.js')\nvar fault = require('fault')\n\n/* The lowlight interface, which has to be compatible\n * with highlight.js, as this object is passed to\n * highlight.js syntaxes. */\n\nfunction High() {}\n\nHigh.prototype = high\n\n/* Expose. */\nvar low = new High() // Ha!\n\nmodule.exports = low\n\nlow.highlight = highlight\nlow.highlightAuto = autoHighlight\nlow.registerLanguage = registerLanguage\nlow.registerAlias = registerAlias\nlow.getLanguage = getLanguage\n\nvar inherit = high.inherit\nvar own = {}.hasOwnProperty\nvar concat = [].concat\n\nvar defaultPrefix = 'hljs-'\nvar keyInsensitive = 'case_insensitive'\nvar keyCachedVariants = 'cached_variants'\nvar space = ' '\nvar pipe = '|'\n\nvar T_ELEMENT = 'element'\nvar T_TEXT = 'text'\nvar T_SPAN = 'span'\n\n/* Maps of syntaxes. */\nvar languageNames = []\nvar languages = {}\nvar aliases = {}\n\n/* Highlighting with language detection.  Accepts a string\n * with the code to highlight.  Returns an object with the\n * following properties:\n *\n * - language (detected language)\n * - relevance (int)\n * - value (a HAST tree with highlighting markup)\n * - secondBest (object with the same structure for\n *   second-best heuristically detected language, may\n *   be absent) */\nfunction autoHighlight(value, options) {\n  var settings = options || {}\n  var subset = settings.subset || languageNames\n  var prefix = settings.prefix\n  var length = subset.length\n  var index = -1\n  var result\n  var secondBest\n  var current\n  var name\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  secondBest = normalize({})\n  result = normalize({})\n\n  while (++index < length) {\n    name = subset[index]\n\n    if (!getLanguage(name)) {\n      continue\n    }\n\n    current = normalize(coreHighlight(name, value, false, prefix))\n\n    current.language = name\n\n    if (current.relevance > secondBest.relevance) {\n      secondBest = current\n    }\n\n    if (current.relevance > result.relevance) {\n      secondBest = result\n      result = current\n    }\n  }\n\n  if (secondBest.language) {\n    result.secondBest = secondBest\n  }\n\n  return result\n}\n\n/* Highlighting `value` in the language `language`. */\nfunction highlight(language, value, options) {\n  var settings = options || {}\n  var prefix = settings.prefix\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  return normalize(coreHighlight(language, value, true, prefix))\n}\n\n/* Register a language. */\nfunction registerLanguage(name, syntax) {\n  var lang = syntax(low)\n\n  languages[name] = lang\n\n  languageNames.push(name)\n\n  if (lang.aliases) {\n    registerAlias(name, lang.aliases)\n  }\n}\n\n/* Register more aliases for an already registered language. */\nfunction registerAlias(name, alias) {\n  var map = name\n  var key\n  var list\n  var length\n  var index\n\n  if (alias) {\n    map = {}\n    map[name] = alias\n  }\n\n  for (key in map) {\n    list = map[key]\n    list = typeof list === 'string' ? [list] : list\n    length = list.length\n    index = -1\n\n    while (++index < length) {\n      aliases[list[index]] = key\n    }\n  }\n}\n\n/* Core highlighting function.  Accepts a language name, or\n * an alias, and a string with the code to highlight.\n * Returns an object with the following properties: */\nfunction coreHighlight(name, value, ignore, prefix, continuation) {\n  var continuations = {}\n  var stack = []\n  var modeBuffer = ''\n  var relevance = 0\n  var language\n  var top\n  var current\n  var currentChildren\n  var offset\n  var count\n  var match\n  var children\n\n  if (typeof name !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', name)\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  language = getLanguage(name)\n  top = continuation || language\n  children = []\n\n  current = top\n  currentChildren = children\n\n  if (!language) {\n    throw fault('Unknown language: `%s` is not registered', name)\n  }\n\n  compileLanguage(language)\n\n  try {\n    top.terminators.lastIndex = 0\n    offset = 0\n    match = top.terminators.exec(value)\n\n    while (match) {\n      count = processLexeme(value.substring(offset, match.index), match[0])\n      offset = match.index + count\n      top.terminators.lastIndex = offset\n      match = top.terminators.exec(value)\n    }\n\n    processLexeme(value.substr(offset))\n    current = top\n\n    while (current.parent) {\n      if (current.className) {\n        pop()\n      }\n\n      current = current.parent\n    }\n\n    return {\n      relevance: relevance,\n      value: currentChildren,\n      language: name,\n      top: top\n    }\n  } catch (error) {\n    /* istanbul ignore if - Catch-all  */\n    if (error.message.indexOf('Illegal') === -1) {\n      throw error\n    }\n\n    return {relevance: 0, value: addText(value, [])}\n  }\n\n  /* Process a lexeme.  Returns next position. */\n  function processLexeme(buffer, lexeme) {\n    var newMode\n    var endMode\n    var origin\n\n    modeBuffer += buffer\n\n    if (lexeme === undefined) {\n      addSiblings(processBuffer(), currentChildren)\n\n      return 0\n    }\n\n    newMode = subMode(lexeme, top)\n\n    if (newMode) {\n      addSiblings(processBuffer(), currentChildren)\n\n      startNewMode(newMode, lexeme)\n\n      return newMode.returnBegin ? 0 : lexeme.length\n    }\n\n    endMode = endOfMode(top, lexeme)\n\n    if (endMode) {\n      origin = top\n\n      if (!(origin.returnEnd || origin.excludeEnd)) {\n        modeBuffer += lexeme\n      }\n\n      addSiblings(processBuffer(), currentChildren)\n\n      /* Close open modes. */\n      do {\n        if (top.className) {\n          pop()\n        }\n\n        relevance += top.relevance\n        top = top.parent\n      } while (top !== endMode.parent)\n\n      if (origin.excludeEnd) {\n        addText(lexeme, currentChildren)\n      }\n\n      modeBuffer = ''\n\n      if (endMode.starts) {\n        startNewMode(endMode.starts, '')\n      }\n\n      return origin.returnEnd ? 0 : lexeme.length\n    }\n\n    if (isIllegal(lexeme, top)) {\n      throw fault(\n        'Illegal lexeme \"%s\" for mode \"%s\"',\n        lexeme,\n        top.className || '<unnamed>'\n      )\n    }\n\n    /* Parser should not reach this point as all\n     * types of lexemes should be caught earlier,\n     * but if it does due to some bug make sure it\n     * advances at least one character forward to\n     * prevent infinite looping. */\n    modeBuffer += lexeme\n\n    return lexeme.length || /* istanbul ignore next */ 1\n  }\n\n  /* Start a new mode with a `lexeme` to process. */\n  function startNewMode(mode, lexeme) {\n    var node\n\n    if (mode.className) {\n      node = build(mode.className, [])\n    }\n\n    if (mode.returnBegin) {\n      modeBuffer = ''\n    } else if (mode.excludeBegin) {\n      addText(lexeme, currentChildren)\n\n      modeBuffer = ''\n    } else {\n      modeBuffer = lexeme\n    }\n\n    /* Enter a new mode. */\n    if (node) {\n      currentChildren.push(node)\n      stack.push(currentChildren)\n      currentChildren = node.children\n    }\n\n    top = Object.create(mode, {parent: {value: top}})\n  }\n\n  /* Process the buffer. */\n  function processBuffer() {\n    var result = top.subLanguage ? processSubLanguage() : processKeywords()\n    modeBuffer = ''\n    return result\n  }\n\n  /* Process a sublanguage (returns a list of nodes). */\n  function processSubLanguage() {\n    var explicit = typeof top.subLanguage === 'string'\n    var subvalue\n\n    /* istanbul ignore if - support non-loaded sublanguages */\n    if (explicit && !languages[top.subLanguage]) {\n      return addText(modeBuffer, [])\n    }\n\n    if (explicit) {\n      subvalue = coreHighlight(\n        top.subLanguage,\n        modeBuffer,\n        true,\n        prefix,\n        continuations[top.subLanguage]\n      )\n    } else {\n      subvalue = autoHighlight(modeBuffer, {\n        subset: top.subLanguage.length === 0 ? undefined : top.subLanguage,\n        prefix: prefix\n      })\n    }\n\n    /* Counting embedded language score towards the\n     * host language may be disabled with zeroing the\n     * containing mode relevance.  Usecase in point is\n     * Markdown that allows XML everywhere and makes\n     * every XML snippet to have a much larger Markdown\n     * score. */\n    if (top.relevance > 0) {\n      relevance += subvalue.relevance\n    }\n\n    if (explicit) {\n      continuations[top.subLanguage] = subvalue.top\n    }\n\n    return [build(subvalue.language, subvalue.value, true)]\n  }\n\n  /* Process keywords. Returns nodes. */\n  function processKeywords() {\n    var nodes = []\n    var lastIndex\n    var keyword\n    var node\n    var submatch\n\n    if (!top.keywords) {\n      return addText(modeBuffer, nodes)\n    }\n\n    lastIndex = 0\n\n    top.lexemesRe.lastIndex = 0\n\n    keyword = top.lexemesRe.exec(modeBuffer)\n\n    while (keyword) {\n      addText(modeBuffer.substring(lastIndex, keyword.index), nodes)\n\n      submatch = keywordMatch(top, keyword)\n\n      if (submatch) {\n        relevance += submatch[1]\n\n        node = build(submatch[0], [])\n\n        nodes.push(node)\n\n        addText(keyword[0], node.children)\n      } else {\n        addText(keyword[0], nodes)\n      }\n\n      lastIndex = top.lexemesRe.lastIndex\n      keyword = top.lexemesRe.exec(modeBuffer)\n    }\n\n    addText(modeBuffer.substr(lastIndex), nodes)\n\n    return nodes\n  }\n\n  /* Add siblings. */\n  function addSiblings(siblings, nodes) {\n    var length = siblings.length\n    var index = -1\n    var sibling\n\n    while (++index < length) {\n      sibling = siblings[index]\n\n      if (sibling.type === T_TEXT) {\n        addText(sibling.value, nodes)\n      } else {\n        nodes.push(sibling)\n      }\n    }\n  }\n\n  /* Add a text. */\n  function addText(value, nodes) {\n    var tail\n\n    if (value) {\n      tail = nodes[nodes.length - 1]\n\n      if (tail && tail.type === T_TEXT) {\n        tail.value += value\n      } else {\n        nodes.push(buildText(value))\n      }\n    }\n\n    return nodes\n  }\n\n  /* Build a text. */\n  function buildText(value) {\n    return {type: T_TEXT, value: value}\n  }\n\n  /* Build a span. */\n  function build(name, contents, noPrefix) {\n    return {\n      type: T_ELEMENT,\n      tagName: T_SPAN,\n      properties: {\n        className: [(noPrefix ? '' : prefix) + name]\n      },\n      children: contents\n    }\n  }\n\n  /* Check if the first word in `keywords` is a keyword. */\n  function keywordMatch(mode, keywords) {\n    var keyword = keywords[0]\n\n    if (language[keyInsensitive]) {\n      keyword = keyword.toLowerCase()\n    }\n\n    return own.call(mode.keywords, keyword) && mode.keywords[keyword]\n  }\n\n  /* Check if `lexeme` is illegal according to `mode`. */\n  function isIllegal(lexeme, mode) {\n    return !ignore && test(mode.illegalRe, lexeme)\n  }\n\n  /* Check if `lexeme` ends `mode`. */\n  function endOfMode(mode, lexeme) {\n    if (test(mode.endRe, lexeme)) {\n      while (mode.endsParent && mode.parent) {\n        mode = mode.parent\n      }\n\n      return mode\n    }\n\n    if (mode.endsWithParent) {\n      return endOfMode(mode.parent, lexeme)\n    }\n  }\n\n  /* Check a sub-mode. */\n  function subMode(lexeme, mode) {\n    var values = mode.contains\n    var length = values.length\n    var index = -1\n\n    while (++index < length) {\n      if (test(values[index].beginRe, lexeme)) {\n        return values[index]\n      }\n    }\n  }\n\n  /* Exit the current context. */\n  function pop() {\n    /* istanbul ignore next - removed in hljs 9.3 */\n    currentChildren = stack.pop() || children\n  }\n}\n\nfunction expandMode(mode) {\n  var length\n  var index\n  var variants\n  var result\n\n  if (mode.variants && !mode[keyCachedVariants]) {\n    variants = mode.variants\n    length = variants.length\n    index = -1\n    result = []\n\n    while (++index < length) {\n      result[index] = inherit(mode, {variants: null}, variants[index])\n    }\n\n    mode[keyCachedVariants] = result\n  }\n\n  return (\n    mode[keyCachedVariants] || (mode.endsWithParent ? [inherit(mode)] : [mode])\n  )\n}\n\n/* Compile a language. */\nfunction compileLanguage(language) {\n  compileMode(language)\n\n  /* Compile a language mode, optionally with a parent. */\n  function compileMode(mode, parent) {\n    var compiledKeywords = {}\n    var terminators\n\n    if (mode.compiled) {\n      return\n    }\n\n    mode.compiled = true\n\n    mode.keywords = mode.keywords || mode.beginKeywords\n\n    if (mode.keywords) {\n      if (typeof mode.keywords === 'string') {\n        flatten('keyword', mode.keywords)\n      } else {\n        Object.keys(mode.keywords).forEach(function(className) {\n          flatten(className, mode.keywords[className])\n        })\n      }\n\n      mode.keywords = compiledKeywords\n    }\n\n    mode.lexemesRe = langRe(mode.lexemes || /\\w+/, true)\n\n    if (parent) {\n      if (mode.beginKeywords) {\n        mode.begin =\n          '\\\\b(' + mode.beginKeywords.split(space).join(pipe) + ')\\\\b'\n      }\n\n      if (!mode.begin) {\n        mode.begin = /\\B|\\b/\n      }\n\n      mode.beginRe = langRe(mode.begin)\n\n      if (!mode.end && !mode.endsWithParent) {\n        mode.end = /\\B|\\b/\n      }\n\n      if (mode.end) {\n        mode.endRe = langRe(mode.end)\n      }\n\n      mode.terminatorEnd = source(mode.end) || ''\n\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        mode.terminatorEnd += (mode.end ? pipe : '') + parent.terminatorEnd\n      }\n    }\n\n    if (mode.illegal) {\n      mode.illegalRe = langRe(mode.illegal)\n    }\n\n    if (mode.relevance === undefined) {\n      mode.relevance = 1\n    }\n\n    if (!mode.contains) {\n      mode.contains = []\n    }\n\n    mode.contains = concat.apply(\n      [],\n      mode.contains.map(function(c) {\n        return expandMode(c === 'self' ? mode : c)\n      })\n    )\n\n    mode.contains.forEach(function(c) {\n      compileMode(c, mode)\n    })\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent)\n    }\n\n    terminators = mode.contains\n      .map(map)\n      .concat([mode.terminatorEnd, mode.illegal])\n      .map(source)\n      .filter(Boolean)\n\n    mode.terminators =\n      terminators.length === 0\n        ? {exec: execNoop}\n        : langRe(terminators.join(pipe), true)\n\n    function map(c) {\n      return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin\n    }\n\n    /* Flatten a classname. */\n    function flatten(className, value) {\n      var pairs\n      var pair\n      var index\n      var length\n\n      if (language[keyInsensitive]) {\n        value = value.toLowerCase()\n      }\n\n      pairs = value.split(space)\n      length = pairs.length\n      index = -1\n\n      while (++index < length) {\n        pair = pairs[index].split(pipe)\n\n        compiledKeywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1]\n      }\n    }\n  }\n\n  /* Create a regex for `value`. */\n  function langRe(value, global) {\n    return new RegExp(\n      source(value),\n      'm' + (language[keyInsensitive] ? 'i' : '') + (global ? 'g' : '')\n    )\n  }\n\n  /* Get the source of an expression or string. */\n  function source(re) {\n    return (re && re.source) || re\n  }\n}\n\n/* Normalize a syntax result. */\nfunction normalize(result) {\n  return {\n    relevance: result.relevance || 0,\n    language: result.language || null,\n    value: result.value || []\n  }\n}\n\n/* Check if `expression` matches `lexeme`. */\nfunction test(expression, lexeme) {\n  var match = expression && expression.exec(lexeme)\n  return match && match.index === 0\n}\n\n/* No-op exec. */\nfunction execNoop() {\n  return null\n}\n\n/* Get a language by `name`. */\nfunction getLanguage(name) {\n  name = name.toLowerCase()\n\n  return languages[name] || languages[aliases[name]]\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
